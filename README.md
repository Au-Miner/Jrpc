# MinerRPC

‰∏≠ÊñáËßÅ [README_CHI](static/README_CHI.md)

## What is MinerRPC
MinerRPC is a pure GO language RPC framework based on Socket+Zookeeper.

MinerRPC supports dynamic proxy, network transmission, serialization, service registration, service discovery, and service invocation.

## Status
Currently, MinerRPC is suitable for learning and small projects, and its performance and stability have been verified in MinerDB.

## Design overview
`TODO`

## Key features
### Dynamic Proxy
MinerRPC is implemented purely in GO language, which is a compiled static language and cannot dynamically obtain Interface/class information like Java through .class files generated by javac. However, we can use reflection to get class object information and dynamically modify the implementation logic of methods in the corresponding object, thereby achieving dynamic proxy for classes.

The specific principle diagram is as follows:

`TODO`

### Service Registry
MinerRPC uses Zookeeper to implement service registration and discovery. When the server starts, it registers the method names and addresses (ip+port) of the implemented class objects to Zookeeper through reflection. The client finds the corresponding service address through the request service name of the proxy object, thereby realizing service invocation.

### Load Balancing
When the client requests a service, it selects the corresponding service address according to the load balancing strategy and supports dynamic vertical scaling.

### Serialization
Currently supports JSON serialization, and is modularly designed for easy custom extension.

### Network Transmission
Uses Socket for network transmission.

## Future Plan
- [ ] Use NIO to replace BIO for network transmission
- [ ] Support more load balancing strategies
- [ ] Support more serialization methods

## Gettings Started
### ZooKeeper
`docker run -d --name zookeeper -p 2181:2181 zookeeper:3.5.8`

### Server
```
package main

import (
	"fmt"
	"minerrpc/rpc_core/transport/transport_server"
	"minerrpc/rpc_server/servers/servers_services"
	"os"
	"os/signal"
)

func main() {
	srv, err := transport_server.NewDefaultSocketServer("localhost:3212")
	if err != nil {
		panic(err)
	}
	ss := servers_services.TestImpl{}
	srv.Register(&ss)
	go srv.Start()

	stopChan := make(chan os.Signal, 1)
	signal.Notify(stopChan, os.Interrupt)
	sig := <-stopChan
	fmt.Printf("Received %v, initiating shutdown...\n", sig)
}

```
### Client
```
package main

import (
	"fmt"
	"minerrpc/rpc_api/api_services"
	"minerrpc/rpc_core/transport/transport_client"
)

func main() {
	client := transport_client.NewDefaultSocketClient()
	proxy := transport_client.NewRpcClientProxy(client)

	testService := proxy.NewProxyInstance(&api_services.Test{}).(*api_services.Test)
	res, _ := testService.Ping()
	fmt.Println("The result is: ", res)
	res, _ = testService.Hello()
	fmt.Println("The result is: ", res)
}
```
## Thanks
MinerRPC is inspired by rrpc and boot4go-proxy, many thanks üôè